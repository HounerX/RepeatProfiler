iMax <-which(v==max)
return(c(iMin,iMax))
}
load("vector.RData")
#v <- c(5,1,9,11,4,3,6,2)
#min_max_index(v4)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)
iMax <-which(v==max)
return(c(iMin,iMax))
}
v4 <- load("vector.RData")
#v <- c(5,1,9,11,4,3,6,2)
#min_max_index(v4)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)
iMax <-which(v==max)
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
#v <- c(5,1,9,11,4,3,6,2)
#min_max_index(v4)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)
iMax <-which(v==max)
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
#v <- c(5,1,9,11,4,3,6,2)
min_max_index(v4)
#min_max_index <- function(v) {
load("vector.RData")
v <-dsc_201_401_vector
min <- min(v)
min
max <- max(v)
max
iMin <- which(v==min)
iMin
iMax <-which(v==max)
iMax
#return(c(iMin,iMax))
#}
load("vector.RData")
#v4 <-dsc_201_401_vector
#v <- c(5,1,9,11,4,3,6,2)
#min_max_index(v4)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)[1]
iMax <-which(v==max)[1]
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
#v <- c(5,1,9,11,4,3,6,2)
min_max_index(v4)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)[1]
iMax <-which(v==max)[1]
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
min_max_index(v4)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)[1]
iMax <-which(v==max)[1]
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
min_max_index(v4)
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
mean(v1[21],v1[22],v1[23],v1[24])
v2 <- c(128, 118, 144, 133, 132, 111, 149, 139, 136, 126, 127, 115, 142, 140, 131, 132, 122, 119, 129, 128)
t.test(v2, mu=120, conf.level=0.95)
t.test(v2, mu=120, conf.level=0.99)
winter <- read.csv("winter2015.csv")
#a
#winter (commented out since it exported to pdf as 3 pages)
#d
bm <- as.vector(winter[21:110,10])
bm <- gsub("T",0.001,bm)
bm <- as.numeric(bm)
bm <- na.omit(bm)
#b
mean(bm)
#c
sum(bm)
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)[1]
iMax <-which(v==max)[1]
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
min_max_index(v4)
library(caret)
bank <- read.csv("bank_data_small.csv")
train_rows <- createDataPartition(y=bank$ExitStatus, p=0.8, list=F)
training <- bank[train_rows, ]
testing <- bank[-train_rows, ]
training$ExitStatus <- factor(training$ExitStatus)
testing$ExitStatus <- factor(testing$ExitStatus)
trctrl <- trainControl(method="repeatedcv", number=10, repeats=3)
svm_radial <- train(ExitStatus ~ ., data=training, method="svmRadial", trControl=trctrl, preProcess=c("center", "scale"), tuneLength=10)
svm_radial
test_pred <- predict(svm_radial,newdata = testing)
test_pred
confusionMatrix(test_pred, testing$ExitStatus)
knitr::opts_chunk$set(echo = TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=80))
min_max_index <- function(v) {
min <- min(v)
max <- max(v)
iMin <- which(v==min)[1]
iMax <-which(v==max)[1]
return(c(iMin,iMax))
}
load("vector.RData")
v4 <-dsc_201_401_vector
min_max_index(v4)
knitr::opts_chunk$set(echo = TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=80))
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
v1[21],v1[22],v1[23],v1[24]
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
v1[21]
v1[22]
v1[23]
v1[24]
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
mean(v1[21],v1[22],v1[23],v1[24])
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
mean(1,1,2,2)
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
v <- c(1,1,2,2)
mean(v)
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
mean(v1[21],v1[22],v1[23],v1[24])
v1 <- seq(from = 1, to = 101, by = 4)
#a
mean(v1)
#b
length(v1)
#c
mean(v1[21:24])
knitr::opts_chunk$set(echo = TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=80))
winter <- read.csv("winter2015.csv")
#a
#winter (commented out since it exported to pdf as 3 pages)
winter
#d
bm <- as.vector(winter[21:110,10])
bm <- gsub("T",0.001,bm)
bm <- as.numeric(bm)
bm <- na.omit(bm)
#b
mean(bm)
#c
sum(bm)
#create and print horizontal plot
horizontalPlot <- ggplot(pileup)+
geom_bar(aes(x = pileup$Position, y = pileup$Depth, color = pileup$Depth), stat = "identity", width = 1.0)+ #creates basic bar plot
#change color of graph based on value of depth
#TODO --> Look into values attribute and rescaler
#scale_colour_gradientn(name = "Depth", colours = colors, values = NULL, space = "Lab", na.value = "black", guide = "colourbar")+
#scale_colour_gradientn(name = "Depth", colours = colors, values = rs, space = "Lab", na.value = "black", guide = "colourbar")+
scale_color_gradientn(name = "Depth", "Depth", colours = colors)+
#scale_color_distiller(name = "Depth", palette = "Spectral")+
theme_bw()+ #to remove grey background
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+ #to remove gridlines
xlab("Position")+ #rename x axis
ylab("Depth")+ #rename y axis
ggtitle("Horizontal Color Map Plot") #rename title of plot
# <- is the assignment operator
class(a)
## Introduction
# <-  are the assignment operators; R intuitively decides the variable type in the background and assigns a class to the variable
# a <- as.character(a) #converts a numeric to a character
a <- 10
class(a)
## Introduction
# <-  are the assignment operators; R intuitively decides the variable type in the background and assigns a class to the variable
# a <- as.character(a) #converts a numeric to a character
a <- 10
class(a)
a <- as.character(a)
class(a)
a <- as.numeric(a)
class(a)
library()
library(ggplot2)
?scale_color_gradientn
?require
?read.table
install.packages(ggplot2)
install.packages("ggplot2")
.libPaths(c("/usr/local/lib/R/3.6/site-library", .libPaths()))
install.packages("ggplot2")
uninstall.packages(ggplot2)
remove.packages(ggplot2)
remove.packages(ggplot2, lib = /usr/local/lib/R/3.6/site-library)
remove.packages("ggplot2")
library()
.libPaths(c("/Users/Anya/Library/R/3.6/library", .libPaths()))
packages()
view.packages()
installed.packages()
.linPaths()
.libPaths()
install.packages("ggplot2")
help(.libPaths)
help(.libPaths())
help(Startup)
help(install.packages)
12/3
installed.packages()
install.packages(ggplot2)
install.packages("ggplot2")
install.packages("yarrr")
?yarrr
??yarrr
library("yarrr")
pirateplot(formulat = weight~Time, data = ChickWeight, pal = "xmen")
pirateplot(formula = weight~Time, data = ChickWeight, pal = "xmen")
?pirates
head(pirates)
aggregate(formula = age!sex, data = pirates, FUN = mean)
aggregate(formula = age~sex, data = pirates, FUN = mean)
plot(x = pirates$height, y = pirates$weight, main = "Height vs. Weight of Pirates")
plot(x = pirates$height, y = pirates$weight,
main = 'Height vs. Weight of Pirates',
xlab = 'Height (in cm)',
ylab = 'Weight (in kg)',
pch = 16, #filled circles
col = grey(.0,.1)) #transparent grey
grid() #adds gridlines
model <- lm(formula = weight~height, data = pirates) #create a linear regression model
abline(model, col = 'blue') #add regression to plot
pirateplot(formula = age~sword.type, data = pirates,
main = "Pirateplot of Ages by Favorite Sword")
pirateplot(formula = height~sex, data = pirates,
main = 'Pirateplot of Height by Sex',
pal = 'pony', #color palette
theme = 3)
#shows the pony palette
piratepal(pallete = 'pony',
plot.result = TRUE, #plot the result
trans = .1) #slightly transparent
#shows the pony palette
piratepal(palerte = 'pony',
plot.result = TRUE, #plot the result
trans = .1) #slightly transparent
#shows the pony palette
piratepal(palette = 'pony',
plot.result = TRUE, #plot the result
trans = .1) #slightly transparent
library()
.libPaths()
help(".libPaths")
.libPaths("/usr/local/Cellar/r/3.6.1/lib/R/library")
.libPaths()
install.packages("yarrr")
installed.packages()
library("yarrr") #package::function --> used to temporarily load a package without using library
#calculates mean age of pirates, separately for each sex
aggregate(formula = age~sex, data = pirates, FUN = mean)
## Plots
plot(x = pirates$height, y = pirates$weight,
main = 'Scatterplot of Pirates Data',
xlab = 'Height (in cm)',
ylab = 'Weight (in kg)',
pch = 16, #filled circles
col = grey(.0,.1)) #transparent grey
grid() #adds gridlines
model <- lm(formula = weight~height, data = pirates) #create a linear regression model
abline(model, col = 'blue') #add regression to plot
pirateplot(formula = height~sex, data = pirates,
main = 'Pirateplot of Height by Sex',
pal = 'pony', #color palette
theme = 3)
#shows the pony palette
piratepal(palette = 'pony',
plot.result = TRUE, #plot the result
trans = .1) #slightly transparent
#hypothesis tests
t.test(formula = age~headband, data = pirates, alternative = 'two.sided') #testing for significant difference between ages of pirates who do wear a headband and those who do not
cor.test(formula = ~height + weight, data = pirates) #testing for correlation between pirates height and weight
#ANOVA Test --> testing if there is a difference between the number of tattoos pirates have based on their favorite sword
tat.sword.lm <- lm(formula = tattoos~sword.type, data = pirates) #create tattoos model
anove(tat.sword.lm)
anova(tat.sword.lm)
## Regression Analysis
tchests.model <- lm(formula = tchests~age + weight + tattoos, data = pirates) #create a linear regression model: DV = tchests, IV = age, weight, tattoos
summary(tchests.model) #show summary statistics
## Bayesian Statistics
library(BayesFactor)
ttestBF(formula = age~headband, data = pirates)
source('~/Documents/GitHub/UR/Programming Languages/R/YaRrr! The Pirates Guide to R.R', echo=TRUE)
install.packages("yarrr")
#https://bookdown.org/ndphillips/YaRrr/
install.packages("yarrr")
library("yarrr") #package::function --> used to temporarily load a package without using library
### Basics
### Descriptive Statistics
#calculates mean age of pirates, separately for each sex
aggregate(formula = age~sex, data = pirates, FUN = mean)
### Plots
plot(x = pirates$height, y = pirates$weight,
main = 'Scatterplot of Pirates Data',
xlab = 'Height (in cm)',
ylab = 'Weight (in kg)',
pch = 16, #filled circles
col = grey(.0,.1)) #transparent grey
grid() #adds gridlines
model <- lm(formula = weight~height, data = pirates) #create a linear regression model
abline(model, col = 'blue') #add regression to plot
pirateplot(formula = height~sex, data = pirates,
main = 'Pirateplot of Height by Sex',
pal = 'pony', #color palette
theme = 3)
#shows the pony palette
piratepal(palette = 'pony',
plot.result = TRUE, #plot the result
trans = .1) #slightly transparent
### Hypothesis Testing
#T Test --> testing for significant difference between ages of pirates who do wear a headband and those who do not
t.test(formula = age~headband, data = pirates, alternative = 'two.sided')
#Correlation Test --> testing for correlation between pirates height and weight
cor.test(formula = ~height + weight, data = pirates)
#ANOVA Test --> testing if there is a difference between the number of tattoos pirates have based on their favorite sword
tat.sword.lm <- lm(formula = tattoos~sword.type, data = pirates) #create tattoos model
anova(tat.sword.lm)
### Regression Analysis
tchests.model <- lm(formula = tchests~age + weight + tattoos, data = pirates) #create a linear regression model: DV = tchests, IV = age, weight, tattoos
summary(tchests.model) #show summary statistics
### Bayesian Statistics
library(BayesFactor)
ttestBF(formula = age~headband, data = pirates)
install.packages("yarrr")
.libPaths
.libPaths()
source('~/Documents/GitHub/UR/Programming Languages/R/YaRrr! The Pirates Guide to R.R', echo=TRUE)
install.packages("yarrr")
### Basics
# R is case-sensitive and has two things: objects and functions.
# Objects are things, like numbers or a dataset or a summary statistic, etc, and have different attributes.
#       numbers         1, 4, 3.12, etc.
#       characters      "a", "10", "Holly", etc.
# objectName <- object assignement
#       - to change an object, you reassign it
# Functions are procedures that typically take one or more objects as arguments.
blackpearl.usd <- 634954103
blackpearl.eur <- blackpearl.usd*0.88
blackpearl.eur
deadman.usd <- 1066215812
deadman.usd/blackpearl.usd
##Testing Chapter 2 R Might
#7 is the only invalid one. #2
gold.in.2015 <- 100800 #3
gold.in.2015 <- gold.in.2015 + 800
plank.list <- "Pirate Skippy McGee"
#10 #5
a <- 10 #5
a + 10 #5
a #5
seq(0, 10, by = 1)
seq(0, 10, by = 3)
cat ("Success! \n",
"user_provided.txt has been created in the current directory using provided reads \n",
"replace temporary (it is a placeholder) with your desired groups\n",
"After that type repeatprof pre-corr -v in the directory you have the user_provided.txt to view your file please and check if it is still in the right format\n")
cat ("Success! \n",
"user_provided.txt has been created in the current directory using provided reads. \n",
"Replace temporary (it is a placeholder) with your desired groups. \n",
"After that type repeatprof pre-corr -v in the directory you have the user_provided.txt to view your file please and check if it is still in the right format. \n")
print("Wrong headers. It should be Read1  Group for unpaired reads or  Read1 Read2 Group for paired reads")
print("Wrong headers. It should be |Read1|Group| for unpaired reads or |Read1|Read2|Group| for paired reads")
args = commandArgs(trailingOnly = TRUE)
if(identical(as.character(args[1]), "-p") || identical(as.character(args[1]), "-u")){
fofn1 <- readLines(file("fofn1.txt", "r"))
fofn2 <- readLines(file("fofn2.txt", "r"))
user_supplied <- data.frame(Read1 = character(), Read2 = character(), Group = character(), stringsAsFactors = FALSE)
for( i in 1:NROW(fofn1)){
first_read = strsplit(fofn1[i], split = "[//|/]")
first_read = first_read[[1]]
first_read = first_read[NROW(first_read)]
second_read = strsplit(fofn2[i], split = "[//|/]")
second_read = second_read[[1]]
second_read = second_read[NROW(second_read)]
user_supplied[i,1] <- first_read
user_supplied[i,2] <- second_read
user_supplied[i,3] <- "temporary"
}
if(identical(user_supplied$Read1,user_supplied$Read2)){
user_supplied$Read2 <- NULL
}
write.table(user_supplied,"user_provided.txt",row.names = FALSE, quote =FALSE,sep = "\t")
cat ("Success!\n")
cat("user_provided.txt has been created in the current directory using provided reads\n")
cat("replace temporary (it is a placeholder) with your desired groups\n")
cat("After that type repeatprof pre-corr -v in the directory you have the user_provided.txt to view your file please and check if it is still in the right format\n")
}
if(identical(as.character(args[1]),"-v")){
user_supplied<-read.table("user_provided.txt",header=TRUE,stringsAsFactors = FALSE)
col_names<-colnames(user_supplied)
if(is.element("Read1",col_names) && is.element("Group",col_names)){
print("it is in correct format. You can go on with profiling with -corr flag  now ")
print(user_supplied)
}else{
print("Wrong Headers. It should be Read1  Group for unpaired reads or  Read1 Read2 Group for paired reads")
}
setwd("/Volumes/SamsungUSB/RP_test/Validation_310719/")
cat ("Success!
user_provided.txt has been created in the current directory using provided reads.
Replace temporary (it is a placeholder) with your desired groups.
After that type repeatprof pre-corr -v in the directory you have the user_provided.txt to view your file please and check if it is still in the right format.")
setwd("V")
setwd("/Volumes/SamsungUSB/RP_test/Tue_Jul_16_10_46_Drosophila2/")
setwd("/Volumes/SamsungUSB/RP_test/Validation_310719/")
setwd("/Volumes/SamsungUSB/RP_test/pipeline_test/")
setwd("./Wed_Jul_31_21_48_47_EDT_2019-RepeatProfiler/")
multmerge <- function(mypath){
filenames <- list.files(path = mypath, full.names = TRUE)
datalist <- lapply(filenames, function(x){read.csv(file = x, header = T)})
Reduce(function(x,y) {merge(x, y, all = TRUE)}, datalist)
}
multmerge <- function(mypath){
filenames <- list.files(path = mypath, full.names = TRUE)
datalist <- lapply(filenames, function(x){read.csv(file = x, header = T)})
Reduce(function(x,y) {merge(x, y, all = TRUE)}, datalist)
}
all.depth <- multmerge('all_depth_cvs')
The.summary <- read.table('The_summary.txt', header = TRUE, stringsAsFactors = FALSE)
#initialize data frame
The.summary$Ref.Length <- NA
The.summary$Average.coverage <- NA
The.summary$max.coverage <- NA
View(The.summary)
index.for.summary <- 1
#fill the reference length
for(i in 2:ncol(all.depth)){
v <- as.vector(all.depth[,i])
ref.length <- sum(!is.na(v))
The.summary[index.for.summary,7] <- ref.length
index.for.summary <- index.for.summary+1
}
index.for.summary <- 1
#fill the reference length
for(i in 2:ncol(all.depth)){
v <- as.vector(all.depth[,i])
ref.length <- sum(!is.na(v))
The.summary[index.for.summary,7] <- ref.length
sum.coverage <- sum(as.numeric(v), na.rm = TRUE)
average.coverage <- sum.coverage/as.numeric(The.summary[index.for.summary,7])
The.summary[index.for.summary,8] <- average.coverage
maximum <- max(v, na.rm = TRUE)
The.summary[index.for.summary,9] <- maximum
index.for.summary <- index.for.summary+1
}
View(The.summary)
setwd("~/Documents/GitHub/RepeatProfiler/")
